/* assemble.c - second pass of the passim assembler.
 * Takes the source file and the symbol table generated by analysis()
 * and assembles the opcodes with the appropriate label values.
 *
 * version 00.01.00
 * Copyright (C) 2009  Joseph Osako
 * This file is part of Pmac-Passim.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * TODO:
 *   - Add commentary.
 *   - output listings to listing file.
 */

#include "passim.h"
#include "symtab.h"
#include "token.h"
#include "errors.h"


bool match_sym(symtable table, symbol** sym);
bool assemble_op();
bool assemble_address();
bool assemble_index();
void emit(WORD value);
void emit_number();


/* assemble() - main second pass of the assembler
   Takes the source file and the symbol table, and
   assembles the instructions and labels to opcodes
   and values.
*/
void assemble()
{
    rewind(source);
    line_no = 0;    // reset line counter for error handler
    token_buffer[0] = '\00';

    printf("   0: ");   // add line # for zeroth line

    while(!feof(source) && ! ferror(dest))
    {
        get_token();

        switch (token_type)
        {
        case T_LABEL:
            // sanity check - is the label in the symbol table?
            if (!match(labels, token_buffer))
            {
                report_err("Label not scanned during analysis phase.");
                eat_line();
            }
            break;

        case T_NAME:
            assemble_op(); // a 'name' is an instruction mnemonic
            break;         // any text other than a label should be a name


        case T_SHARP:
            // next toekn should be a numeric literal
            get_token();
            if (T_NUMBER != token_type)
            {
                report_err("Number expect after sharp sign");
                eat_line();
            }
            else
            {
                emit_number();
            }
            break;

            // if the next token is either the end of a line or the end of
            // the file, continue the loop
        case T_NEWLINE:
        case T_END:
            break;

            // no meaningful input, report an error
        default:
            report_err("Label or instruction expected");
            eat_line();
            break;
        }
    }
}

/* match_sym() - check if a symbol is in the symbol table
*/

bool match_sym(symtable table, symbol** sym)
{
    symbol* fetched_sym;
    fetched_sym = match(table, token_buffer);
    *sym = fetched_sym;

    return (NULL != fetched_sym);
}



bool assemble_op()
{
    symbol *op_sym, *label_sym;
    bool err_flag = false;

    if (match_sym(opcodes, &op_sym))
    {
        emit(op_sym ->value);
    }
    else if (match_sym(address_args, &op_sym))
    {
        emit(op_sym ->value);
        get_token();
        if (match_sym(labels, &label_sym))
        {
            emit(label_sym ->value);
        }
        else
        {
            report_err("Label expected.");
            eat_line();
            err_flag = false;
        }

    }
    else if (match_sym(direct_args, &op_sym))
    {
        emit(op_sym ->value);
        get_token();
        if (T_NUMBER == token_type)
        {
            emit_number();

        }
        else if (T_AT == token_type)
        {
            if(!assemble_address())
            {
                report_err("Label or value expected.");
                eat_line();
                err_flag = false;
            }
        }
        else
        {
            report_err("Value expected.");
            eat_line();
            err_flag = false;
        }
    }
    else if (match_sym(indexed_args, &op_sym))
    {
        if(!assemble_address())
        {
            report_err("Label expected.");
            eat_line();
            err_flag = false;
        }
        else if(!assemble_address())
        {
            report_err("Label not found in analysis phase.");
            eat_line();
            err_flag = false;
        }
    }
    else
    {
        report_err("Instruction expected.");
        eat_line();
        err_flag = false;
    }

    get_token();

    if (T_NEWLINE != token_type)
    {
        report_err("Too many arguments");
        eat_line();
        err_flag = false;
    }
    return err_flag;
}


/* emit() - write out the hex value for the opcode or address.
*/
void emit(WORD value)
{
    if (0 > fprintf(dest, "%04X\n", value))
    {
        finish("Cannot write to output file - FATAL", FAIL);
    }
}


/* emit_number() - emit a numeric literal as a hex value
   This is a special case of emit, as the numeric literal is already
   a hex string and should simply be passed through unchanged.
*/
void emit_number()
{
    if (0 > fprintf(dest, "%s\n", token_buffer))
    {
        finish("Cannot write to output file - FATAL", FAIL);
    }
}



bool assemble_address()
{
    symbol* label_sym;

    get_token();
    if(T_NUMBER == token_type)
    {
        emit_number();
    }
    else if (T_NAME == token_type)
    {
        if (match_sym(labels, &label_sym))
        {
            emit(label_sym ->value);
        }
    }
    else
    {
        return false;
    }
    return true;
}

bool assemble_index()
{
    symbol* label_sym;

    get_token();

    if (T_LBRACKET != token_type)
    {
        report_err("Index syntax error - missing left bracket.");
        return false;
    }
    else
    {
        get_token();
        if(T_NUMBER == token_type)
        {
            emit_number();
        }
        else if ((T_NAME == token_type) && (match_sym(direct_args, &label_sym)))
        {
            emit(label_sym ->value);
        }
        else
        {
            report_err("Index expected");
            return false;
        }

        get_token();

        if (T_RBRACKET != token_type)
        {
            report_err("Index syntax error - missing right bracket.");
            return false;
        }
    }
    return true;
}
